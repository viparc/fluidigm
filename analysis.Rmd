---
title: "Dynamics of resistance genes concentrations after antimicrobial treatment"
output:
  html_document:
    toc: true
    toc_depth: 4
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Required packages

We need the following packages:

```{r}
required_packages <- c("readxl",
                       "purrr",
                       "dplyr",
                       "stringr",
                       "tidyr",
                       "magrittr",
                       "AMR")
```

Installing those that are not already installed on the system:

```{r}
for (package in required_packages) {
  if (!package %in% installed.packages()) install.packages(package)
}
```

Loading the packages:

```{r message = FALSE}
devnull <- lapply(required_packages, require, character.only = TRUE)
```

## Loading the data

### Antimicrobial use

Date and type of antimicrobial use per farm:

```{r}
amu <- read_excel("AMU_KietStudy_Marc.xlsx")
```

### Antimicrobial classes

Antimicrobial class of each antimicrobial:

```{r}
classes <- read_excel("FarmvsClass.xlsx")
```

### Resistance genes concentrations

The names of the farms:

```{r}
(farms <- paste0("K", c(formatC(6:9, 1, flag = "0"), 11:26)))
```

Let's start by looking at the resistance genes concentrations in chicken only
(maybe we'll look at the rat data later on):

```{r}
genes <- farms %>%
  map(read_excel, path = "KietAnalysisData.xlsx") %>% 
  map(filter, Group.1 %in% c("Chicken-Control", "Chicken-Treatment")) %>% 
  map(select, -Group.1, -TotalLog2Value) %>% 
  setNames(farms)
```

Let's check that the names of the columns are the same for all the farms:

```{r}
tmp <- genes %>%
  map_df(names) %>% 
  apply(1, unique)

tmp[map_int(tmp, length) > 1]
```

There is a problem with with the `FarmID` variable that is called `K09` is one
farm. Let's fix this. The names of the variables seem OK in the first farm:

```{r}
(correct_names <- names(genes[[1]]))
```

Let's use them as variables names for all the farms:

```{r}
genes %<>% map(setNames, correct_names)
```

Note also that not all farms have a "Before" measurement in the control group:

```{r}
tmp <- genes %>%
  map(~ .x %>% filter(SamplingDay == "Before") %>% select(Group)) %>% 
  .[map_int(., nrow) < 2] %>% 
  unlist()

tmp
```

For the farms where the "Before" measurement is missing in the control group,
let's just use the "Before" measurement of the treatment group. For that, we
need the following function where `x` is a dataframe for one farm:

```{r}
control_before <- function(x) {
  y <- filter(x, SamplingDay == "Before")
  y$Group <- "Control"
  y$Sample_Name <- NA
  rbind(x, y)
}
```

Let's now we can use this function on all the farms that needed to be fixed:

```{r}
farms_to_fix <- tmp %>% 
  names() %>% 
  str_remove(".Group")

fixed_farms <- genes %>% 
  magrittr::extract(farms_to_fix) %>% 
  map(control_before)

genes[farms_to_fix] <- fixed_farms
```

Names of resistance genes:

```{r}
(resistance_genes <- setdiff(names(genes[[1]]),
                             c("FarmID", "Group", "Sample_Name", "SamplingDay")))
```

## Preparing the data

### Computing sums of resistance genes

Here we compute aggregates of resistance genes, these aggregates being the sum
of all the resistance genes but also the sum of all the resistance genes by
class of antimicrobial against which they are effective. The correspondence
between resistance genes and antimicrobial resistance is in the `classes`
data frame:

```{r}
classes
```

Let's add a category `All` that corresponds to all the resistance genes:

```{r}
classes %<>% 
  bind_rows(data.frame(EvaGreen_Name = resistance_genes,
                       Antimicrobial_Class = "All"))
```

The antimicrobial classes to which each resistance gene corresponds are now:

```{r}
(classes_names <- unique(classes$Antimicrobial_Class))
```

The following function calculates the sum of the genes concentration for a given
class `am_class` for the data frame of a given farm `farm`:

```{r}
sum_by_class <- function(am_class, farm) {
  classes %>%
    filter(Antimicrobial_Class == am_class) %>% 
    pull(EvaGreen_Name) %>% 
    extract(farm, .) %>% 
    rowSums()
}
```

The following function uses the one above and adds as many variables as
antimicrobial classes to the data frame of a given farm:

```{r}
add_sums_by_class <- function(farm) {
  farm %>%
    map_dfc(classes_names, sum_by_class, .) %>% 
    setNames(classes_names) %>% 
    bind_cols(farm, .)
}
```

Let's add the sums of concentrations to all the farms:

```{r message  = FALSE}
genes %<>% map(add_sums_by_class)
```

### Antimicrobial classes for AMU

The classes of the antimicrobials used:

To work out the classes of antimicrobials used we first need to define a hash
table that allows to match classes names as found by the `AMR` package and the
classes names recorded in our `amu` data:

```{r}
#          AMR package:                  amu dataset:
hash <- c("Aminoglycosides"           = "Aminoglycoside",
          "Amphenicols"               = "Phenicol",
          "Antifungals/antimycotics"  = "Antifungals/antimycotics",
          "Beta-lactams/penicillins"  = "Beta-Lactam",
          "Cephalosporins (3rd gen.)" = "Beta-Lactam",
          "Macrolides/lincosamides"   = "MLSB",
          "Other antibacterials"      = "Other",
          "Polymyxins"                = "Polymyxin",
          "Quinolones"                = "Quinolone",
          "Tetracyclines"             = "Tetracycline",
          "Trimethoprims"             = "Sulfonamide")
```

Let's generate the correspondence data frame:

```{r}
amu_classes <- amu %>% 
  select(AAI) %>% 
  unique() %>% 
  mutate(group = map_chr(AAI, ab_group),
         class = hash[group])

amu_classes
```

Let's check for missing values:

```{r}
amu_classes %>% 
  filter(is.na(AAI) | is.na(group) | is.na(class))
```

Let's fix it manually:

```{r}
amu_classes[amu_classes$AAI == "bromhexine", "class"] <- "Mucoactive agent"
```

Finally, we can use `amu_classes` to make another hash table:

```{r}
hash <- with(amu_classes, setNames(class, AAI))
```

And we can use this new hash table to add the antimicrobial class to the `amu`
dataframe:

```{r}
(amu %<>% mutate(class = hash[AAI]))
```

## Data visualization

### Plotting the raw data per farm and gene

The time points:

```{r}
genes %>%
  map(pull, SamplingDay) %>% 
  unlist() %>% 
  unique()
```

Generating new time points:

```{r}
genes %<>% map(mutate,
               SamplingDay2 = as.integer(recode(SamplingDay,
                                                Before = "-7",
                                                After  = "0",
                                                End    = "120"))) %>% 
  map(arrange, Group, SamplingDay2) # making sure that data are arranged chronologically
```

Some customized `lines()` and `points()` function:

```{r}
lines2 <- function(...) lines(..., lwd = 2)
```

A utility function for the function `plot_gene_concentration()` that follows
after. This function adds the dots and lines to a plot:

```{r}
plot_data <- function(x, gene, col, lwd = 2, lty = 3) {
  lines2 <- function(...) lines(..., col = col, lwd = lwd)
  nrows <- nrow(x)
  x2 <- x[-c(1, nrows), ]
  x3 <- x[1:2, ]
  x4 <- x[(nrows - 1):nrows, ]
  points(x$SamplingDay2, x[[gene]], col = col, lwd = lwd)
  lines2(x2$SamplingDay2, x2[[gene]])
  lines2(x3$SamplingDay2, x3[[gene]], lty = lty)
  lines2(x4$SamplingDay2, x4[[gene]], lty = lty)
}
```

The following function plots a given gene concentration as a function of time
for control and treatment:

```{r}
plot_gene_concentration <- function(farm, gene, text) {
  farm_dataset <- genes[[farm]]
  
  plot(farm_dataset$SamplingDay2, farm_dataset[[gene]], type = "n",
       xlim = c(-10, 120), xlab = "time after treatment (days)",
       ylab = "gene concentration", axes = FALSE)
  ats <- c(-7, seq(0, 120, 20))
  lbs <- ats
  lbs[1] <- "before"
  lbs[length(lbs)] <- "end"
  axis(1, ats, lbs)
  axis(2)

  farm_dataset %>%
    filter(Group == "Control") %>% 
    plot_data(gene, "blue")
  
  farm_dataset %>%
    filter(Group == "Treatment") %>% 
    plot_data(gene, "red")

  mtext(text)
  abline(v = 0)
}
```

Plotting `aac3-liacde` for control and treatment in farm K06

```{r}
plot_gene_concentration(farms[1], resistance_genes[1], resistance_genes[1])
```

#### Plotting all the genes for a given farm

Number of columns we want and some graph tuning:

```{r}
ncols <- 3
plt_val <- c(.13, .92, .22, .9)
```

Plotting all the genes for the first farm:

```{r fig.height = ceiling(length(resistance_genes) / ncols) * (1 + 2 / 3), fig.width = 2.45 * ncols}
opar <- par(mfrow = c(ceiling(length(resistance_genes) / ncols), ncols), plt = plt_val)
walk(resistance_genes, ~ plot_gene_concentration(farms[1], .x, .x))
par(opar)
```

#### Plotting all the farms for a given gene

Plotting all the farms for the first gene:

```{r fig.height = ceiling(length(farms) / ncols) * (1 + 2 / 3), fig.width = 2.45 * ncols}
opar <- par(mfrow = c(ceiling(length(farms) / ncols), ncols), plt   = plt_val)
walk(farms, ~ plot_gene_concentration(.x, resistance_genes[1], .x))
par(opar)
```

### Gathering data per gene

#### Standardizing the data

Let's now try to standardize the gene concentrations by the gene concentration
before treatment. This function standardizes one experiment:

```{r}
standardize_by_before_ <- function(x) {
  rbind(rep(1, length(resistance_genes)),
        sweep(as.matrix(x[x$SamplingDay != "Before", resistance_genes]), 2,
                 unlist(x[x$SamplingDay == "Before", resistance_genes]), `/`))
}
```

This function standardizes the control and the treatment experiments of a farm:

```{r}
standardize_by_before <- function(x) {
  x[, resistance_genes] <- rbind(standardize_by_before_(filter(x, Group == "Control")),
                                 standardize_by_before_(filter(x, Group == "Treatment")))
  
  x
}
```

Let's standardize the gene concentrations for all the farms:

```{r}
genes_standardized <- map(genes, standardize_by_before)
```

Let's now plot all the farms on a single plot for a given antimicrobial. Let's
first define the following function that draw the layout the plot:

```{r}
plot_frame <- function(...) {
  plot(..., type = "n", xlab = "time (days)", ylab = "standardized genes concentrations")
}
```

#### Experiments time series

Now, we can start exploring various option of plotting the data, starting with
this function:

```{r}
plot_gene_all_farms <- function(gene, infinity = -1000) {
  transformation <- function(x) {
    x[, 3] <- log10(x[, 3])
    x
  }
  
  tmp <- genes_standardized %>%
    map(extract, c("Group", "SamplingDay2", gene)) %>%
    map(transformation)

  tmp2 <- bind_rows(tmp)
  plot_frame(tmp2[[2]], tmp2[[3]])

  a <- tmp %>% 
    map(function(x) {x[[3]] <- replace(x[[3]], is.infinite(x[[3]]), infinity); x}) %>% 
    map(~ split(.x, .x$Group)) %>% 
    unlist(recursive = FALSE) %>% 
    map(mutate, col = c("blue", "red")[(Group == "Treatment") + 1]) %>% 
    sample() %>% 
    walk(~ lines2(.x[[2]], .x[[3]], col = .x$col))
  
  mtext(gene)
  abline(h = 0)
  legend("topright", legend = c("treatment", "control"), col = c("red", "blue"),
         lty = 1, lwd = 2, bty = "n")
}
```

Let's try it on one antimicrobial:

```{r}
plot_gene_all_farms(resistance_genes[1], -1000)
```

#### Boxplots

Let's try an alternative visualization, using this following function for
box-plots:

```{r}
boxplot2 <- function(x, eps, col, ...) {
  boxplot(x[[3]] ~ x[[2]], at =  unique(x[[2]]) + eps, add = TRUE, axes = FALSE,
          boxwex = 2.5, col = adjustcolor(col, .5), outline = FALSE, ...)
}
```

Here is the alternative visualization:

```{r}
plot_gene_all_farms_boxplot <- function(antimicrobial) {
  eps <- 1.5
  
  tmp <- genes_standardized %>% 
    map(filter, SamplingDay != "Before") %>% 
    map(extract, c("Group", "SamplingDay2", antimicrobial))

  tmp2 <- bind_rows(tmp)
  plot_frame(tmp2[[2]], tmp2[[3]])

  control <- map(tmp, filter, Group == "Control")
  walk(control, ~ points(jitter(.x[[2]] - 2), .x[[3]], col = "blue"))
  control %>%
    bind_rows() %>% 
    boxplot2(-eps, col = "blue")
  
  treatment <- map(tmp, filter, Group == "Treatment")
  walk(treatment, ~ points(jitter(.x[[2]] + 2), .x[[3]], col = "red"))
  treatment %>%
    bind_rows() %>% 
    boxplot2(eps, col = "red")
  
  mtext(antimicrobial)
  legend("topright", legend = c("treatment", "control"), fill = c("red", "blue"), bty = "n")
}
```

Let's try it:

```{r}
plot_gene_all_farms_boxplot(resistance_genes[1])
```

Mmmm... For some reason, interquartiles ranges look a bit weird on some of these
boxplots. Not sure how this is calculated but I don't really like it.

#### Violin plots

Let's try a violin plot instead, by using this function:

```{r}
vioplot2 <- function(x, eps, color, ...) {
  vioplot::vioplot(x[[3]] ~ x[[2]], at =  unique(x[[2]]) + eps, add = TRUE,
                   axes = FALSE, fill = color, lineCol = color, border = color,
                   wex = 4, col = adjustcolor(color, .5), ...)
}
```

And the new plotting function:

```{r}
plot_gene_all_farms_violin <- function(antimicrobial) {
  eps <- 1.5
  
  tmp <- genes_standardized %>% 
    map(filter, SamplingDay != "Before") %>% 
    map(extract, c("Group", "SamplingDay2", antimicrobial))

  tmp2 <- bind_rows(tmp)
  plot_frame(tmp2[[2]], tmp2[[3]])

  control <- map(tmp, filter, Group == "Control")
  walk(control, ~ points(jitter(.x[[2]] - 2), .x[[3]], col = "blue"))
  control %>%
    bind_rows() %>% 
    vioplot2(-eps, "blue")
  
  treatment <- map(tmp, filter, Group == "Treatment")
  walk(treatment, ~ points(jitter(.x[[2]] + 2), .x[[3]], col = "red"))
  treatment %>%
    bind_rows() %>% 
    vioplot2(eps, "red")
  
  mtext(antimicrobial)
  legend("topright", legend = c("treatment", "control"), fill = c("red", "blue"), bty = "n")
}
```

Let's try it too:

```{r}
plot_gene_all_farms_violin(resistance_genes[1])
```

Not sure I like it either...

#### Paired treatment and control

Let's plot paired treatment and control for each farm instead. For that, we need
the following function:

```{r}
plot_gene_all_farms_pairwise <- function(antimicrobial) {
  col_val <- adjustcolor(c("blue", "red"), .5)

  genes %>% 
    map(extract, c("SamplingDay2", "Group", antimicrobial)) %>% 
    map(pivot_wider, names_from = Group, values_from = 3) %>% 
    bind_rows() %>% 
    mutate(SamplingDay3 = jitter(SamplingDay2),
           color = (Treatment > Control) + 1) %>% 
    with({
      plot_frame(rep(SamplingDay3, 2), c(Control, Treatment))
      points(SamplingDay3, Control, col = "blue")
      points(SamplingDay3, Treatment, col = "red")
      arrows(SamplingDay3, Control, SamplingDay3, Treatment, 0, col = col_val[color])
    })
  
  mtext(antimicrobial)
}
```

Let's try it:

```{r}
plot_gene_all_farms_pairwise(resistance_genes[1])
```

### Differences between treatment and control

#### Experiment time series

Let's plot the difference between treatment and control for each farm. For that,
we need the following function:

```{r}
plot_differences <- function(antimicrobial) {
  tmp <- genes %>% 
    map(extract, c("SamplingDay2", "Group", antimicrobial)) %>% 
    map(pivot_wider, names_from = Group, values_from = 3) %>% 
    map(mutate, difference = Treatment - Control)

  tmp %>% 
    bind_rows() %$% 
    plot_frame(SamplingDay2, difference)
  
  walk(tmp, ~ with(.x, lines2(SamplingDay2, difference, col = "green")))

  abline(h = 0)
  mtext(antimicrobial)
}
```

Let's try it:

```{r}
plot_differences(resistance_genes[1])
```

#### Boxplots

Let's consider this function with boxplots:

```{r}
plot_differences_boxplot <- function(antimicrobial) {
  
  tmp <- genes %>% 
    map(extract, c("SamplingDay2", "Group", antimicrobial)) %>% 
    map(pivot_wider, names_from = Group, values_from = 3) %>% 
    map(mutate, difference = Treatment - Control) %>% 
    bind_rows()

  with(tmp, plot(jitter(SamplingDay2), difference, col = "green",
                 xlab = "time (days)",
                 ylab = "difference in standardized genes concentrations"))
  
  tmp %>% 
    select(2, 1, 3) %>% 
    boxplot2(0, col = "green")

  abline(h = 0)
  mtext(antimicrobial)
}
```

Let's try it:

```{r}
plot_differences_boxplot(resistance_genes[1])
```

The boxplot still looks weird.

#### Violin plots

Let's look at the violin alternative:

```{r}
plot_differences_violin <- function(antimicrobial) {
  
  tmp <- genes %>% 
    map(extract, c("SamplingDay2", "Group", antimicrobial)) %>% 
    map(pivot_wider, names_from = Group, values_from = 3) %>% 
    map(mutate, difference = Treatment - Control) %>% 
    bind_rows()

  with(tmp, plot(jitter(SamplingDay2), difference, col = "green",
                 xlab = "time (days)",
                 ylab = "difference in standardized genes concentrations"))
  
  tmp %>% 
    select(2, 1, 3) %>% 
    vioplot2(0, col = "green")

  abline(h = 0)
  mtext(antimicrobial)
}
```

Let's try it:

```{r}
plot_differences_violin(resistance_genes[1])
```

Same comment.

#### Quantiles

Let's consider another option.

```{r}
plot_differences_quantiles <- function(antimicrobial) {
  tmp <- genes %>% 
    map(extract, c("SamplingDay2", "Group", antimicrobial)) %>% 
    map(pivot_wider, names_from = Group, values_from = 3) %>% 
    map(mutate, difference = Treatment - Control) %>% 
    bind_rows()

  with(tmp, plot(jitter(SamplingDay2), difference, col = "darkgrey",
                 xlab = "time (days)",
                 ylab = "difference in standardized genes concentrations"))

  x_val <- sort(unique(tmp$SamplingDay2))
  
  tmp %>%
    select(SamplingDay2, difference) %>% 
    group_by(SamplingDay2) %>% 
    group_split() %>% 
    map(~ quantile(.x$difference, c(.25, .5, .75), na.rm = TRUE)) %>% 
    bind_rows() %>% 
    mutate(x_val = x_val) %>% 
    with({
      points(x_val, `50%`, lwd = 2)
      arrows(x_val, `25%`, x_val, `75%`, .1, 90, 3, lwd = 2, col = "black")
      lines(x_val, `25%`, lty = 3)
      lines(x_val, `50%`, lty = 2)
      lines(x_val, `75%`, lty = 3)
    })
  
  abline(h = 0)
  mtext(antimicrobial)
}
```

Let's try it:

```{r}
plot_differences_quantiles(resistance_genes[1])
```

